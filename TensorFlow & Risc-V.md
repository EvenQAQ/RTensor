# TensorFlow & Risc-V

## TensorFlow依赖

Bazel ！！！！！

NewLib（Lite）

## TensorFlow并行计算

ts使用数据流（Dataflow-like model）式图规划计算流程，可以同时使用不同的硬件资源（CPU、GPU、TPU）进行训练，同步或**异步**地更新全局共享的模型参数和状态。



## TensorFlow与Risc-V机器

移动处理器的NPU（RISC-V阵营），CPU与NPU的频繁信息传递

标准的训练流程：

a) pre-processing the inputs to render them consumable by a neural network

b) running a neural network inference using these inputs

c) post-processing the predic- tions generated by the network

### tensorflow lite on Spike ISS（RISC-V）

vectors registers I/O ALU

.tflite model 

lightweight   hardware acceleration

TensorFlow Lite  two implementations; reference_ops and optimized_ops, for machine learn- ing kernels such as convolution and depthwise-convolution. The reference_ops implementation is portable, hardware-independent and uses standard C/C++ libraries. The optimized_ops is a hard- ware specific optimized implementation of kernel operations us-ing gemmlowp, Eigen libraries and other processor specific optimizations. For example, in the case of ARM processors, the optimized_ops implementation leverages gemmlowp（General Matrix to Matrix Multiplication low precision，低精度矩阵乘法库）, Eigen libraries（矩阵库） and Neon（单指令多数据流） instructions  to optimize kernel operations

generate a binary that can run on a RISC-V processor that has micro-architectural support for the RISC-V V ISA extension.

### RVTensor

**2019 BenchCouncil International Artificial Intelligence System Challenges**

Resnet20 model

![](/Users/evenqaq/Pictures/ScreenShots/截屏2019-12-26上午5.20.48.png)

**Model analysis**. It mainly parses model files such as *.pb*, and extracts information such as operator operations and weight data.
 **Op operators**. It mainly includes the implementation of each operator, including conv, add, active, pooling, fc* [14] and other operations. These operators are the basic computing unit of the neural network execution.

**Construction the calculation graph**. It builds a calculation graph based on the model analysis and the op operator modules. In the calculation graph, the order between the operators, the dependencies between the weights and the operators are clarified.

**Execution the calculation graph**. It obtains the inference results based on the input data (such as image data) and the calculation graph.

RVTensor is optimized for resource-poor scenarios by reducing dependencies on third- party libraries and increasing memory utilization

reimplement pthread main methods

### Arm

https://github.com/lhelontra/tensorflow-on-arm

https://tensorflow.google.cn/lite/guide/build_arm64

## Reference

- Towards Deep Learning using TensorFlow Lite on RISC-V
- RVTensor: A light-weight neural network inference framework based on the RISC-V architecture
- Implementation of DNN on a RISC-V Open Source Microprocessor for IoT devices



## 可能有用

- Session定义时的device_count（对intel多核的原生支持）
- inter_op_parallelism_threads  intra_op_parallelism_threads
- 多GPU显存控制
- 直接编译ts最大的麻烦bazel
- 读一下tf和tflite源码，tflite有arm64



## Question

- 我们的编译器和核心阵列的特点和资料（怎么编译的，语言，可操作性）
- 理论上移植个bazel？
- risc-v指令集拓展
- lite有好像更容易？
- 领域内靠谱的会议和期刊（筛选文献）



# 开题答辩

## 背景

### 4096阵列众核处理器

众核设计有助于提高芯片的能效(Power-Efficiency)

已有众核芯片自称适用的应用领域，包括生物计算、网络安全、虚拟现实、信号处理（GSM、MPEG-4、压缩、滤波等）、国土安全（加密解密、模式匹配、搜索等）、网络包处理、生物特征识别、图形处理、移动游戏、服务器组件和机器人学习等

应用算法本身特性主要体现在三个方面，即应用算法是否有足够的并行度，计算和访存的比例是否合适，是否强调单线程速度。如果应用算法本身难于进行并行划分，或者非常强调单线程速度，那就不适合在众核设计上进行并行化，而更适于在指令集并行性开发更好的超标量处理器上执行；如果应用算法对计算能力的需求不高，而数据处理量很大，那也不适合在众核上进行加速，因为目前众核设计最大的限制就是访存带宽

### 深度学习框架

ts主流

ts使用数据流（Dataflow-like model）式图规划计算流程，可以同时使用不同的硬件资源（CPU、GPU、TPU）进行训练，同步或**异步**地更新全局共享的模型参数和状态。  很高的理论并行度

ts有在Arm64的实现，交叉编译

RISC-V基金会(RISC-V Foundation)早期成员Google将展示其TensorFlow Lite软件，瞄准在RISC-V芯片上执行Zephyr操作系统(OS)的嵌入式系统。

tflite处于待完善状态，但是在riscv架构下效率很高，可以用于对训练后模型的使用





# 2.28 讨论

## 遇到的问题

## 使用官方编译的 c 库进行链接

include成功，能链接到，但是会报undefined reference

```
▶ riscv64-unknown-elf-gcc hello_tf.c -Ltensorflow -o hello_tf
/opt/riscv/lib/gcc/riscv64-unknown-elf/9.2.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/cccFZu9U.o: in function `main':
hello_tf.c:(.text+0x8): undefined reference to `TF_Version'
collect2: error: ld returned 1 exit status
```

尝试加入-l 链接官方的动态库

```
▶ riscv64-unknown-elf-gcc hello_tf.c -ltensorflow -ltensorflow_framework -o hello_tf
/opt/riscv/lib/gcc/riscv64-unknown-elf/9.2.0/../../../../riscv64-unknown-elf/bin/ld: 当搜索用于 /opt/riscv/lib/gcc/riscv64-unknown-elf/9.2.0/libtensorflow.so 时跳过不兼容的 -ltensorflow 
/opt/riscv/lib/gcc/riscv64-unknown-elf/9.2.0/../../../../riscv64-unknown-elf/bin/ld: 当搜索用于 /opt/riscv/lib/gcc/riscv64-unknown-elf/9.2.0/../../../../riscv64-unknown-elf/lib/libtensorflow.so 时跳过不兼容的 -ltensorflow 
/opt/riscv/lib/gcc/riscv64-unknown-elf/9.2.0/../../../../riscv64-unknown-elf/bin/ld: 当搜索用于 /opt/riscv/riscv64-unknown-elf/lib/libtensorflow.so 时跳过不兼容的 -ltensorflow 
/opt/riscv/lib/gcc/riscv64-unknown-elf/9.2.0/../../../../riscv64-unknown-elf/bin/ld: 当搜索用于 /opt/riscv/riscv64-unknown-elf/lib/libtensorflow.so 时跳过不兼容的 -ltensorflow 
/opt/riscv/lib/gcc/riscv64-unknown-elf/9.2.0/../../../../riscv64-unknown-elf/bin/ld: 找不到 -ltensorflow
/opt/riscv/lib/gcc/riscv64-unknown-elf/9.2.0/../../../../riscv64-unknown-elf/bin/ld: 当搜索用于 /opt/riscv/lib/gcc/riscv64-unknown-elf/9.2.0/libtensorflow_framework.so 时跳过不兼容的 -ltensorflow_framework 
/opt/riscv/lib/gcc/riscv64-unknown-elf/9.2.0/../../../../riscv64-unknown-elf/bin/ld: 当搜索用于 /opt/riscv/lib/gcc/riscv64-unknown-elf/9.2.0/../../../../riscv64-unknown-elf/lib/libtensorflow_framework.so 时跳过不兼容的 -ltensorflow_framework 
/opt/riscv/lib/gcc/riscv64-unknown-elf/9.2.0/../../../../riscv64-unknown-elf/bin/ld: 当搜索用于 /opt/riscv/riscv64-unknown-elf/lib/libtensorflow_framework.so 时跳过不兼容的 -ltensorflow_framework 
/opt/riscv/lib/gcc/riscv64-unknown-elf/9.2.0/../../../../riscv64-unknown-elf/bin/ld: 当搜索用于 /opt/riscv/riscv64-unknown-elf/lib/libtensorflow_framework.so 时跳过不兼容的 -ltensorflow_framework 
/opt/riscv/lib/gcc/riscv64-unknown-elf/9.2.0/../../../../riscv64-unknown-elf/bin/ld: 找不到 -ltensorflow_framework
collect2: error: ld returned 1 exit status
```

均是不兼容的

如果这种思路可行的话，错误的来源可能是 x86 的可执行文件、动态库并不符合 riscv

### 直接 bazel 的尝试

 bazel编译出 tf 的可执行库---Linux 虚拟机出现了 timed out ，换成主机尝试

### 两个思路

#### 修改 bazel 的 默认gcc

##### 直接修改



##### 源码编译时设置 gcc 选项



#### 直接用 gcc 进行编译

目前未搜到相关的资料



To build Bazel from source, you can do one of the following:

- Build it using an existing Bazel binary
- Build it without an existing Bazel binary which is known as bootstrapping

尝试第二个引导方式，下面是依赖

```
sudo apt-get install build-essential openjdk-8-jdk python zip unzip
```

# 会议思想

去掉众核、暂时去掉优化

在处理器架构和学习框架上的优化

lapack 和 gfortran



## 3.6

### 主要工作：

参照了 arm_compilier.BUILD 指定了arm 架构的 gcc 工具链

仿照编写了 riscv_compiler.BUILD 完成了工具链的定向

路径还需要再读，把工具加到 tf 的目

正在学习和编写.bzl 需要 riscv 平台的还有 cc_config.bzl 

还需要修改的是BUILD 文件和 configure.py，实在太长理解比较困难,configure生成.bazelrc比较重要，还需要学习



### 并行的：

yocto（可能的话尝试在上面引导 bazel，可能比交叉编译直观一些）

antmicro 有一套开源的riscv tflite 的 demo，在配置学习（网络问题比较慢），结合找到的几篇 paper 希望能尽快跑通 tflite 作为保底



### 会议思想

交叉编译

Eigen is a C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms.

gemmlowp: a small self-contained low- precision GEMM library



```
--cxxopt="-D_GLIBCXX_USE_CXX11_ABI=0"
```



## 3.13

### 进度

跑通了 litex/vexriscv 的 tflite demo，在 zephyr上 magic wand

尝试指定 bazel 的 cxxopt 选项，失败

```
--cxxopt="-D_GLIBCXX_USE_CXX11_ABI=0"
```

基本上彻底明确了bazel 的编译结构



```
# Tensorflow
tensorflow
	WORKSPACE
  configure.py
  configure
  .bazelrc
  tensorflow
    WORKSPACE
    BUILD
    riscv_compiler.BUILD
    workspace.bzl
    tensorflow.bzl
```

```
# Tensorflow-Lite
tensorflow
	WORKSPACE
	riscv-compiler
		BUILD
		CROSSTOOL
		cross_toolchain_target_riscv.BUILD
	build_riscv.sh
	build_tflite.sh
tensorflow/contrib/lite/kernels/internal/BUILD
```

错误：

```
java.io.IOException: Error downloading # 墙

external/nsync/BUILD:401:13: Configurable attribute "copts" doesn't match this configuration
solve: /external/nsync/BUILD


```

 



